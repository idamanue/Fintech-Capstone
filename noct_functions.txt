# Read CSv file and Return dataframe given module ID from the user
def get_csv(user_input):
    pathname = "Data/test_samples/" + user_input + ".csv"
    df = pd.read_csv(Path(pathname), header=1, usecols = ['TIMESTAMP', 'AirTemp_Avg', 'Irradiance_Pyr_NOCT_Avg', 'Wind_speed', 	'Wind_direction', 'NOCT_Mod1_Cent1_Avg', 'NOCT_Mod1_Cent2_Avg'])
    #df = pd.read_csv(Path(pathname))

    return df


# Create model
def create_model():
    model = Sequential()
    model.add(Dense(64, activation="relu", input_dim=4))
    model.add(Dense(16, activation="relu"))
    model.add(Dense(4, activation="relu"))
    
    # Since the regression is performed, a Dense layer containing a single neuron with a linear activation function.
    # Typically ReLu-based activation are used but since it performs regression, it needs a linear activation.
    model.add(Dense(1, activation="linear"))
    
    # Compile model: The model is initialized with the Adam optimizer and then it is compiled.
    model.compile(loss='mean_squared_error', optimizer=Adam(lr=1e-3, decay=1e-3 / 200))
    
    return model


# Train the model
def fit_model(model, monitor, epoch):
    # Patient early stopping
    es = EarlyStopping(monitor=monitor, mode='min', verbose=1, patience=200)
    
    # Fit the model
    history = model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=epoch, batch_size=100, verbose=2, callbacks=[es])
    
    return history


# Saving the model
def saving_model(model, filename):
    # Save a model using the HDF5 format
    model.save(filename)


# Load a model from the HDF5 format
def loading_model(filename):
    loaded_h5_model = tf.keras.models.load_model(filename)
    
    return loaded_h5_model


# Calculate predictions
def calculate_predictions(model):
    predictions = {}
    predictions['train'] = model.predict(X_train)
    predictions['test'] = model.predict(X_test)
    
    return predictions


# Plot training history
def plot_training(history, filepath):
    plt.plot(history.history['loss'], label='train')
    plt.plot(history.history['val_loss'], label='test')
    plt.legend()
    plt.savefig(filepath)


# Plot actual vs prediction
def actual_prediction_plot(y, prediction_set, title, filepath):
    plt.plot(y,prediction_set,'ro')
    plt.title(title)
    plt.xlabel('Actual')
    plt.ylabel('Predicted')
    plt.savefig(filepath)


# Compute scores value for a set
def compute_metrics(y, prediction_set):
    scores = []
    scores.append(metrics.r2_score(y,prediction_set))
    scores.append(metrics.mean_squared_error(y,prediction_set))
    
    return scores


# Compute NOCT value
def compute_noct(model):
    x = pd.DataFrame(columns=['irradiance', 'wind_speed', 'wind_direction', 'ambient_temperature'])
    x.loc[0] = [800,1,120,20]
    x = np.asarray(x)
    x=tf.convert_to_tensor(x, dtype=tf.int32)
    y_pred = model.predict(x)
    noct = float("{:.2f}".format( y_pred[0][0] ))
    
    return noct